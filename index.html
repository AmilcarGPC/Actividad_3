<html><head></head><body>
      <canvas width="570" height="570" id="my_Canvas"></canvas>
      <!-- Botones de control -->
      <div style="margin: 10px 0;">
        <button id="btnUp">Arriba (W/↑)</button>
        <button id="btnDown">Abajo (S/↓)</button>
        <button id="btnLeft">Izquierda (A/←)</button>
        <button id="btnRight">Derecha (D/→)</button>
      </div>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
<script import="" {vec3,="" mat4}="" from="" src="https://webgpufundamentals.org/3rdparty/wgpu-matrix.module.js" ;="">
</script>
      <script>
         main();
         function main(){
            var canvas = document.getElementById('my_Canvas');
            gl = canvas.getContext('experimental-webgl');
            if(gl == null){
               alert("Error. Aborting.....");
               return;
            }
            //cilindro
            var sides = 10;
            var height = 0.01;
            var stepTheta = 2 * Math.PI / sides;
            var verticesPerCap = 9 * sides;

            var verticesCyl = [];
            var colorsCyl = [];
            var theta = 0;
            var i = 0;

            // Top Cap
            color_random_r = Math.random()
            color_random_g = Math.random()
            color_random_b = Math.random()

            const scale = 0.15;

            const trans = 0;

            for (; i < verticesPerCap; i += 9) {
               verticesCyl[i    ] = scale*Math.cos(theta) + trans; colorsCyl[i]=color_random_b;
               verticesCyl[i + 1] = height;          colorsCyl[i+1]=color_random_r;
               verticesCyl[i + 2] = scale*Math.sin(theta) + trans; colorsCyl[i+2]=color_random_g;
               theta += stepTheta;

               verticesCyl[i + 3] = 0.0 + trans;             colorsCyl[i+3]=color_random_b;
               verticesCyl[i + 4] = height;          colorsCyl[i+4]=color_random_r;
               verticesCyl[i + 5] = 0.0 + trans;             colorsCyl[i+5]=color_random_g;

               verticesCyl[i + 6] = scale*Math.cos(theta) + trans; colorsCyl[i+6]=color_random_b;
               verticesCyl[i + 7] = height;          colorsCyl[i+7]=color_random_r;
               verticesCyl[i + 8] = scale*Math.sin(theta) + trans; colorsCyl[i+8]=color_random_g;
            }

            // Bottom Cap
            theta = 0;
            for (; i < verticesPerCap + verticesPerCap; i += 9) {
               verticesCyl[i + 6] = scale*Math.cos(theta) + trans; 
               verticesCyl[i + 7] = -height;
               verticesCyl[i + 8] = scale*Math.sin(theta) + trans;
               theta += stepTheta;

               verticesCyl[i + 3] = 0.0 + trans;
               verticesCyl[i + 4] = -height;
               verticesCyl[i + 5] = 0.0 + trans;

               verticesCyl[i    ] = scale*Math.cos(theta) + trans;
               verticesCyl[i + 1] = -height;
               verticesCyl[i + 2] = scale*Math.sin(theta) + trans;
            }

            for (var j = 0; j < sides; ++j) {
               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[0 + k + 9 * j];
               }
               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[6 + k + 9 * j];
               }
               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[verticesPerCap + k + 9 * j];
               }

               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[0 + k + 9 * j];
               }
               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[verticesPerCap + k + 9 * j];
               }
               for (var k = 0; k < 3; ++k, ++i) {
                  verticesCyl[i] = verticesCyl[verticesPerCap + 6 + k + 9 * j];
               }
            }

            var indicesCyl = new Array(verticesCyl.length / 3);
            for (i = 0; i < indicesCyl.length; ++i) indicesCyl[i] = i;
         //===================

         // for (let i = 0; i < numObjects; ++i) {
         //    const across = Math.sqrt(numObjects) | 0;
         //    const x = (i % across - (across - 1) / 2) * 3;
         //    const y = ((i / across | 0) - (across - 1) / 2) * 3;

         //    objectInfos.push({
         //       translation: [x, y, 0],
         //    });
         //}

         //===================
            var vertex_bufferCyl = gl.createBuffer ();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferCyl);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesCyl), gl.STATIC_DRAW);
            //
            var color_bufferCyl = gl.createBuffer ();
            gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferCyl);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorsCyl), gl.STATIC_DRAW);
            //
            var index_bufferCyl = gl.createBuffer ();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_bufferCyl);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indicesCyl), gl.STATIC_DRAW);
            //
            var vertCode = 'attribute vec3 position;'+
               'uniform mat4 Pmatrix;'+
               'uniform mat4 Vmatrix;'+
               'uniform mat4 Mmatrix;'+
               'attribute vec3 color;'+
               'varying vec3 vColor;'+

               'void main(void) { '+
                  'gl_Position = Pmatrix*Vmatrix*Mmatrix*vec4(position, 1.);'+
                  'vColor = color;'+
               '}';
            var fragCode = 'precision mediump float;'+
               'varying vec3 vColor;'+
               'void main(void) {'+
                  'gl_FragColor = vec4(vColor, 1.);'+
               '}';
            var vertShader = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vertShader, vertCode);
            gl.compileShader(vertShader);
            var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fragShader, fragCode);
            gl.compileShader(fragShader);
            var shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertShader);
            gl.attachShader(shaderProgram, fragShader);
            gl.linkProgram(shaderProgram);
            //matrices Cylinder
            var PmatrixCyl = gl.getUniformLocation(shaderProgram, "Pmatrix");
            var VmatrixCyl = gl.getUniformLocation(shaderProgram, "Vmatrix");
            var MmatrixCyl = gl.getUniformLocation(shaderProgram, "Mmatrix");
            var proj_matrixCyl = get_projection(40, canvas.width/canvas.height, 1, 100);
            var mov_matrixCyl = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            var view_matrixCyl = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            view_matrixCyl[14] = view_matrixCyl[14]-2
            //buffers
            var positionCyl;
            var colorCyl;
            
            //================Cylinder
            //buffers
            gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferCyl);
            positionCyl = gl.getAttribLocation(shaderProgram, "position");
            gl.vertexAttribPointer(positionCyl, 3, gl.FLOAT, false,0,0) ;
            gl.enableVertexAttribArray(positionCyl);
            gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferCyl);
            colorCyl = gl.getAttribLocation(shaderProgram, "color");
            gl.vertexAttribPointer(colorCyl, 3, gl.FLOAT, false,0,0) ;
            gl.enableVertexAttribArray(colorCyl);
            gl.useProgram(shaderProgram);
            //animation

            // ============================================
            // ***            CÓDIGO EDITADO            ***
            // ============================================
            var time_old = 0;
            var mov_matrixCyl = [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
            rotateX(mov_matrixCyl, Math.PI/2);

            // Inicializar los ángulos a 0
            var ax = 0;
            var ay = 0;
            // Dirección a favor o en contra del reloj
            var dir = (-1)**(Math.floor(Math.random()*2))

            // --- Control de rotación por botones y teclado ---
            function rotarArriba() {
              rotateX(view_matrixCyl, 0.1);
            }
            function rotarAbajo() {
              rotateX(view_matrixCyl, -0.1);
            }
            function rotarIzquierda() {
              rotateY(view_matrixCyl, -0.1);
            }
            function rotarDerecha() {
              rotateY(view_matrixCyl, 0.1);
            }
            document.getElementById('btnUp').onclick = rotarArriba;
            document.getElementById('btnDown').onclick = rotarAbajo;
            document.getElementById('btnLeft').onclick = rotarIzquierda;
            document.getElementById('btnRight').onclick = rotarDerecha;
            document.addEventListener('keydown', function(e) {
              if (e.key === 'w' || e.key === 'ArrowUp') rotarArriba();
              if (e.key === 's' || e.key === 'ArrowDown') rotarAbajo();
              if (e.key === 'a' || e.key === 'ArrowLeft') rotarIzquierda();
              if (e.key === 'd' || e.key === 'ArrowRight') rotarDerecha();
            });
            // --- Fin controles ---

            var animate = function(time) {
               
               gl.enable(gl.DEPTH_TEST);
               gl.depthFunc(gl.LEQUAL);
               gl.clearColor(0.5, 0.5, 0.5, 0.9);
               gl.clearDepth(1.0);
               gl.viewport(0.0, 0.0, canvas.width, canvas.height);
               gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

               // Operaciones de rotación y traslación
               var dt = time-time_old;
               rotateZ(mov_matrixCyl, -1*dir*dt*0.005); // Propio eje
               trasladaX(mov_matrixCyl, Math.cos(ax*0.01)) // Alrededor de un punto (eje x)
               trasladaY(mov_matrixCyl, Math.sin(ay*0.01)) // Alrededor de un punto (eje y)
               

               ax += 1*dir;
               ay += 1*dir;
               time_old = time;
               //================================== Cylinder
               gl.bindBuffer(gl.ARRAY_BUFFER, vertex_bufferCyl);
               positionCyl = gl.getAttribLocation(shaderProgram, "position");
               gl.vertexAttribPointer(positionCyl, 3, gl.FLOAT, false,0,0) ;
               gl.enableVertexAttribArray(positionCyl);
               gl.bindBuffer(gl.ARRAY_BUFFER, color_bufferCyl);
               colorCyl = gl.getAttribLocation(shaderProgram, "color");
               gl.vertexAttribPointer(colorCyl, 3, gl.FLOAT, false,0,0) ;
               gl.enableVertexAttribArray(colorCyl);
               gl.useProgram(shaderProgram);

               gl.uniformMatrix4fv(PmatrixCyl, false, proj_matrixCyl);
               gl.uniformMatrix4fv(VmatrixCyl, false, view_matrixCyl);
               gl.uniformMatrix4fv(MmatrixCyl, false, mov_matrixCyl);
               gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_bufferCyl);
               gl.drawElements(gl.TRIANGLES, indicesCyl.length, gl.UNSIGNED_SHORT, 0);
               //================================== Cylinder
               window.requestAnimationFrame(animate);
            }
            animate(0);
         }
         //======================================================
         function get_projection(angle, a, zMin, zMax) {
            var ang = Math.tan((angle*.5)*Math.PI/180);//angle*.5
            return [
               0.5/ang, 0 , 0, 0,
               0, 0.5*a/ang, 0, 0,
               0, 0, -(zMax+zMin)/(zMax-zMin), -1,
               0, 0, (-2*zMax*zMin)/(zMax-zMin), 0 
            ];
         }
         //======================================================
         function trasladaX(m, desplazaX) {
            m[12]=desplazaX;
         }
         function trasladaY(m, desplazaY) {
            m[13]=desplazaY;
         }
         function trasladaZ(m, desplazaZ) {
            m[14]=desplazaZ;
         }
         //======================================================
         function rotateY(m, angle) {
            
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8];

            m[0] = c*m[0]+s*m[2];
            m[4] = c*m[4]+s*m[6];
            m[8] = c*m[8]+s*m[10];

            m[2] = c*m[2]-s*mv0;
            m[6] = c*m[6]-s*mv4;
            m[10] = c*m[10]-s*mv8;
         }
         //======================================================
         function rotateX(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv1 = m[1], mv5 = m[5], mv9 = m[9];

            m[1] = m[1]*c-m[2]*s;
            m[5] = m[5]*c-m[6]*s;
            m[9] = m[9]*c-m[10]*s;

            m[2] = m[2]*c+mv1*s;
            m[6] = m[6]*c+mv5*s;
            m[10] = m[10]*c+mv9*s;
         }

         function rotateZ(m, angle) {
            var c = Math.cos(angle);
            var s = Math.sin(angle);
            var mv0 = m[0], mv4 = m[4], mv8 = m[8]; 

            m[0] = c*m[0]-s*m[1];
            m[4] = c*m[4]-s*m[5];
            m[8] = c*m[8]-s*m[9];

            m[1] = c*m[1]+s*mv0;
            m[5] = c*m[5]+s*mv4;
            m[9] = c*m[9]+s*mv8;
         }
         //======================================================
         function updateMatrix() {

         }
         //======================================================
         function sub (a, b) { return [a[0] - b[0], a[1] - b[1], a[2] - b[2]]; };
  function cross (a, b) {
    return [
      a[1] * b[2] - a[2] * b[1],
      a[2] * b[0] - a[0] * b[2],
      a[0] * b[1] - a[1] * b[0]
    ];
  };
  //======================================================
  function normalize (a) {
    var length = a[0] * a[0] + a[1] * a[1] + a[2] * a[2];
    return [a[0] / length, a[1] / length, a[2] / length];
  };
  //======================================================
  function createBuffer(gl, data, type = gl.ARRAY_BUFFER) {
    const buf = gl.createBuffer();
    gl.bindBuffer(type, buf);
    gl.bufferData(type, data, gl.STATIC_DRAW);
    return buf;
  }
//======================================================
      </script>
   
</body></html>